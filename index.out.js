"use strict";
(() => {
  // dist/crypto/libFourQ_K12.js
  var encodedWasmFile = "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aiIAaiIGIABzIAAgDXNyIAZzIAkgAEF/c3FyQR92aiIAaiIJIABzIAAgDHNyIAlzIAEgAEF/c3FyQR92aiIAQR92IARqIgE2AiAgAyAEIAFBf3NxQR92IAZqIgE2AiQgAyAGIAFBf3NxQR92IAlqIgE2AiggAyAAQf////8HcSAJIAFBf3NxQR92ajYCLCACIA8gAkGAAWoiABANIAIgDyACQeAAaiIBEAcgACADIAIQBiATIAMgEhAGIAEgEyAPEAYgA0FAayQAC1UBAn8gAEHgAGoiAiACIAFB4ABqIgIQByAAIABBIGoiAyABEAcgAyAAIAFBIGoQDSACIABBgAFqIAIQBiAAQUBrIgAgACABQUBrEAcgAkHgCCACEAYL5AMBA38gACACaiEDAkACQAJAIAAgAXNBA3FFBEAgAEEDcUUNASACQQBMDQEgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQMgAiADSQ0ACwwCCwJAIANBBEkNACADQQRrIgQgAEkNACAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwwDCyAAIQIMAgsgACECCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANAIAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIUNgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiABKAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFAayICIAVNDQALCyACIARPDQADQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwsgAiADSQRAA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAAL4gEBA38gAC0AyQFFBEAgAgRAA0AgAiAFayEDAkACQCAALQDIASIEDQAgBUGoAWogAksNACADQagBTwRAA0AgACABQQBBqAEQQAJAIAAQFQsgAUGoAWohASADQagBayIDQacBSw0ACwsgAiADayEFDAELIAAgASAEQagBIARr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QQF2aiAMIARBf3NxIAQgCnMgAyAEc3IgCnNyQR92ajYCDCABIAkgE2sgBkEBdmogCyACQX9zcSAAIAJzIAIgBnNyIABzckEfdmo2AhwgASABKAIgIgJBAWoiA0F+IAEoAiQiAGsgAEF/c3IgAHNBH3ZBfiACayACQX9zciACc0EfdiIGIABBAWoiBSAASXFyIgcgASgCKCIAQQFqIgkgAElxQX4gAGsgAEF/c3IgAHNBH3ZyIgggASgCLCIAQf////8HayICRXEgAiAAQX9zcUEfdnIiAGsiBDYCICABIAIgCGtBACAAayICQQF2aiAJIAdrIgcgBSAGayIGIAMgBHMgAiADc3IgBHNBH3ZqIgMgAGsiBCADcyACIANzciAEcyAGIANBf3NxckEfdmoiAyAAayIAIANzIAIgA3NyIABzIAcgA0F/c3FyQR92ajYCLCABIAA2AiggASAENgIkIAEgASgCMCICQQFqIgNBfiABKAI0IgBrIABBf3NyIABzQR92QX4gAmsgAkF/c3IgAnNBH3YiAiAAQQFqIgUgAElxciIHIAEoAjgiAEEBaiIJIABJcUF+IABrIABBf3NyIABzQR92ciIIIAEoAjwiAEH/////B2siBEVxIAQgAEF/c3FBH3ZyIgBrIgY2AjAgASAFIAJrIgUgBiADIAZzIANBACAAayICc3JzQR92aiIDIABrIgY2AjQgASAJIAdrIgcgBSADQX9zcSADIAZzIAIgA3NyIAZzckEfdmoiAyAAayIANgI4IAEgBCAIayACQQF2aiAHIANBf3NxIAAgA3MgAiADc3IgAHNyQR92ajYCPAuWAgEJfyAAIAAoAgAiAUEBaiIEQX4gACgCCCICayACQX9zciACc0EfdkF+IAAoAgQiA2sgA0F/c3IgA3NBH3ZBfiABayABQX9zciABc0EfdiIBIANBAWoiBSADSXFyIgYgAkEBaiIIIAJJcXIiCSAAKAIMIgJB/////wdrIgdFcSAHIAJBf3NxQR92ciICayIDNgIAIAAgBSABayIFIAMgAyAEcyAEQQAgAmsiA3Nyc0EfdmoiASACayIENgIEIAAgCCAGayIGIAUgAUF/c3EgASAEcyABIANzciAEc3JBH3ZqIgEgAmsiAjYCCCAAIAYgAUF/c3EgASACcyABIANzciACc3JBH3YgA0EBdmogByAJa2o2AgwL4QEBCX8gAiAAKAIAIgMgASgCACIEayIHNgIAIAIgACgCBCIFIAEoAgQiBmsiCCADIAQgB3MgAyAEc3JzQR92IgtrIgM2AgQgAiAAKAIIIgQgASgCCCIJayIKIAsgCEVxIAUgBiAIcyAFIAZzcnNBH3ZyIgZrIgU2AgggAiAHIAAoAgwgASgCDCAGIApFcSAEIAkgCnMgBCAJc3JzQR92cmprIgBBH3YiAWs2AgAgAiADIAEgB0VxIgFrNgIEIAIgBSABIANFcSIBazYCCCACIABB/////wdxIAEgBUVxazYCDAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAutCQEjfyAAKAJ8IQogACgCeCEYIAAoAnQhGSAAKAJwIRogACgCbCELIAAoAmghGyAAKAJkIRwgACgCYCEdIAAoAlwhHiAAKAJYIR8gACgCVCEgIAAoAlAhISAAKAJMISIgACgCSCEjIAAoAkQhJCAAQUBrKAIAISUgACgCPCEMIAAoAjghDSAAKAI0IQ4gACgCMCEPIAAoAiwhECAAKAIoIREgACgCJCESIAAoAiAhEyAAKAIcIQYgACgCGCEHIAAoAhQhCCAAKAIQIQkgACgCDCEUIAAoAgghFSAAKAIEIRYgACgCACEXQQEhJgNAIAJBAWsiAkEfdkEBayIEIAAgJkEHdGoiBSgCACAXc3EgF3MhFyAFKAJ8IApzIARxIApzIQogBSgCbCALcyAEcSALcyELIAUoAlwgHnMgBHEgHnMhHiAFKAJMICJzIARxICJzISIgBSgCPCAMcyAEcSAMcyEMIAUoAiwgEHMgBHEgEHMhECAFKAIcIAZzIARxIAZzIQYgBSgCDCAUcyAEcSAUcyEUIAUoAnggGHMgBHEgGHMhGCAFKAJoIBtzIARxIBtzIRsgBSgCWCAfcyAEcSAfcyEfIAUoAkggI3MgBHEgI3MhIyAFKAI4IA1zIARxIA1zIQ0gBSgCKCARcyAEcSARcyERIAUoAhggB3MgBHEgB3MhByAFKAIIIBVzIARxIBVzIRUgBSgCdCAZcyAEcSAZcyEZIAUoAmQgHHMgBHEgHHMhHCAFKAJUICBzIARxICBzISAgBSgCRCAkcyAEcSAkcyEkIAUoAjQgDnMgBHEgDnMhDiAFKAIkIBJzIARxIBJzIRIgBSgCFCAIcyAEcSAIcyEIIAUoAgQgFnMgBHEgFnMhFiAFKAJwIBpzIARxIBpzIRogBSgCYCAdcyAEcSAdcyEdIAUoAlAgIXMgBHEgIXMhISAFQUBrKAIAICVzIARxICVzISUgBSgCMCAPcyAEcSAPcyEPIAUoAiAgE3MgBHEgE3MhEyAFKAIQIAlzIARxIAlzIQkgJkEBaiImQQhHDQALIAEgHjYCXCABIB82AlggASAgNgJUIAEgITYCUCABICI2AkwgASAjNgJIIAEgJDYCRCABQUBrICU2AgAgASADIBhzQX9zNgJ4IAEgAyAZc0F/czYCdCABIAMgGnNBf3M2AnAgASADIBtzQX9zNgJoIAEgAyAcc0F/czYCZCABIAMgHXNBf3M2AmAgASAGIAxzIANxIgAgBnM2AjwgASAHIA1zIANxIgIgB3M2AjggASAIIA5zIANxIgQgCHM2AjQgASAJIA9zIANxIgUgCXM2AjAgASAQIBRzIANxIgYgFHM2AiwgASARIBVzIANxIgcgFXM2AiggASASIBZzIANxIgggFnM2AiQgASATIBdzIANxIgkgF3M2AiAgASAAIAxzNgIcIAEgAiANczYCGCABIAQgDnM2AhQgASAFIA9zNgIQIAEgBiAQczYCDCABIAcgEXM2AgggASAIIBJzNgIEIAEgCSATczYCACABQf////8HIAprIgAgCnMgA3EgAHM2AnwgAUH/////ByALayIAIAtzIANxIABzNgJsC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACQQYRAAALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACAB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AkEBNgKgASAAKQAIIQwgACkAECENIAApAAAhDiABIAApABg3ADggASANNwAwIAEgDDcAKCABQSBqIgMgDjcAACAALQAfIQsgASABKAI8Qf////8HcTYCPCADIAJB4AFqIgUQCCAFQYCFAiACQcABaiIGEAYgBSACQaABaiIAIAUQDSAGIAAgBhAHIAYgAkHAAmoiABAcIAJB0AFqIgMgAkGwAmoiBxAcIAAgByAAECMgBSAGIAcQBSACQfABaiIAIAMgAkGgAmoiBBAFIAcgBCAHECMgACAGIAQQBSAFIAMgAkGQAmoiAxAFIAQgAyAEEDMgByADEBwgBCACQYACaiIAEBwgAyAAIAMQI0EAIQADQCACQZACaiIDIAMQHCAAQQFqIgBB/QBHDQALIAJBsAJqIAJBkAJqIAJB0AJqIgAQIyAAEDIgAigC3AIgAigC2AIgAigC1AIgAigC0AJycnJFBEAgAkGwAmogAkGQAmogAkHQAmoQMwsgAkHQAmoiCSAJIAkQIyACQcACaiIDIAJBkAJqIggQHCADIAggCBAFIAkgCCAIEAUgCCACQeACaiIAEEogAyAAIAgQBSAJIAggARAFIAEgAkGwAmoiChAcIAMgCiAKEAUgASABKAIEIgMgASgCACIAQQAgAEEBcSIEayIFcyAAc0EfdiAEayIGaiIHQR90IABBAXZyNgIAIAEgASgCCCIAIAUgBkF/c3EgBiAHcyADIAZzciAHc3JBH3YgBGsiBGoiA0EfdCAHQQF2cjYCBCABIAEoAgwgBSAEQX9zcSADIARzIAAgBHNyIANzckEfdiAFQQF2amoiAEEBdjYCDCABIABBH3QgA0EBdnI2AgggAkGgAmogCCABQRBqIgMQBSAJIAogCRAzIAkQMiACKALcAiACKALYAiACKALUAiACKALQAnJycgRAIAJBwAJqIgAgASgCADYCACAAIAEoAgQ2AgQgACABKAIINgIIIAAgASgCDDYCDCABIAMoAgA2AgAgASADKAIENgIEIAEgAygCCDYCCCABIAMoAgw2AgwgAyAAKAIANgIAIAMgACgCBDYCBCADIAAoAgg2AgggAyAAKAIMNgIMCyABEDIgAUEMQRwgASgCDCABKAIIIAEoAgQgASgCAHJychtqKAIAQR52IAtBB3ZHBEAgARBHCyABIAIQRQJ/IAIQKEUE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AhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAyACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiADIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAQgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAUgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSAGIAIgAhAFIAIgAiACEAUgACACIAEQBSAEQdAAaiQAC48FAgZ+AX8gASABKAIAQQdqQXhxIgFBEGo2AgAgAAJ8IAEpAwAhAyABKQMIIQYjAEEgayIIJAACQCAGQv///////////wCDIgRCgICAgICAwIA8fSAEQoCAgICAgMD/wwB9VARAIAZCBIYgA0I8iIQhBCADQv//////////D4MiA0KBgICAgICAgAhaBEAgBEKBgICAgICAgMAAfCECDAILIARCgICAgICAgIBAfSECIANCgICAgICAgIAIhUIAUg0BIAIgBEIBg3whAgwBCyADUCAEQoCAgICAgMD//wBUIARCgICAgICAwP//AFEbRQRAIAZCBIYgA0I8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIARC////////v//DAFYNAEIAIQIgBEIwiKciAEGR9wBJDQAgAyECIAZC////////P4NCgICAgICAwACEIgUhBwJAIABBgfcAayIBQcAAcQRAIAIgAUFAaq2GIQdCACECDAELIAFFDQAgByABrSIEhiACQcAAIAFrrYiEIQcgAiAEhiECCyAIIAI3AxAgCCAHNwMYAkBBgfgAIABrIgBBwABxBEAgBSAAQUBqrYghA0IAIQUMAQsgAEUNACAFQcAAIABrrYYgAyAArSICiIQhAyAFIAKIIQULIAggAzcDACAIIAU3AwggCCkDCEIEhiAIKQMAIgNCPIiEIQIgCCkDECAIKQMYhEIAUq0gA0L//////////w+DhCIDQoGAgICAgICACFoEQCACQgF8IQIMAQsgA0KAgICAgICAgAiFQgBSDQAgAkIBgyACfCECCyAIQSBqJAAgAiAGQoCAgICAgICAgH+DhL8LOQMAC74YAxJ/AXwCfiMAQbAEayILJAAgC0EANgIsAkAgAb0iGUIAUwRAQQEhEEGOhwIhEyABmiIBvSEZDAELIARBgBBxBEBBASEQQZGHAiETDAELQZSHAkGPhwIgBEEBcSIQGyETIBBFIRQLAkAgGUKAgICAgICA+P8Ag0KAgICAgICA+P8AUQRAIABBICACIBBBA2oiAyAEQf//e3EQCiAAIBMgEBAJIABB54cCQamIAiAFQSBxIgUbQfiHAkGtiAIgBRsgASABYhtBAxAJIABBICACIAMgBEGAwABzEAogAiADIAIgA0obIQkMAQsgC0EQaiERAkACfwJAIAEgC0EsahA5IgEgAaAiAUQAAAAAAAAAAGIEQCALIAsoAiwiBkEBazYCLCAFQSByIg5B4QBHDQEMAwsgBUEgciIOQeEARg0CIAsoAiwhCkEGIAMgA0EASBsMAQsgCyAGQR1rIgo2AiwgAUQAAAAAAACwQaIhAUEGIAMgA0EASBsLIQwgC0EwaiALQdACaiAKQQBIGyINIQcDQCAHAn8gAUQAAAAAAADwQWMgAUQAAAAAAAAAAGZxBEAgAasMAQtBAAsiAzYCACAHQQRqIQcgASADuKFEAAAAAGXNzUGiIgFEAAAAAAAAAABiDQALAkAgCkEATARAIAohAyAHIQYgDSEIDAELIA0hCCAKIQMDQCADQR0gA0EdSRshAwJAIAdBBGsi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";
  var Module = typeof Module !== "undefined" ? Module : {};
  var moduleOverrides = {};
  var key;
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key];
    }
  }
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = function(status, toThrow) {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = typeof window === "object";
  var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
  var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_;
  var readAsync;
  var readBinary;
  var setWindowTitle;
  var nodeFS;
  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = self.location.href;
    } else if (typeof document !== "undefined" && document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
    } else {
      scriptDirectory = "";
    }
    {
      read_ = function(url) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, false);
        xhr.send(null);
        return xhr.responseText;
      };
      if (ENVIRONMENT_IS_WORKER) {
        readBinary = function(url) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.responseType = "arraybuffer";
          xhr.send(null);
          return new Uint8Array(xhr.response);
        };
      }
      readAsync = function(url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function() {
          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
            onload(xhr.response);
            return;
          }
          onerror();
        };
        xhr.onerror = onerror;
        xhr.send(null);
      };
    }
    setWindowTitle = function(title) {
      document.title = title;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.warn.bind(console);
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key];
    }
  }
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var noExitRuntime = Module["noExitRuntime"] || true;
  if (typeof WebAssembly !== "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort("Assertion failed: " + text);
    }
  }
  var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heap, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heap[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(heap.subarray(idx, endPtr));
    } else {
      var str = "";
      while (idx < endPtr) {
        var u0 = heap[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heap[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heap[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  }
  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  }
  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  }
  function lengthBytesUTF8(str) {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343)
        u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
      if (u <= 127)
        ++len;
      else if (u <= 2047)
        len += 2;
      else if (u <= 65535)
        len += 3;
      else
        len += 4;
    }
    return len;
  }
  var buffer;
  var HEAP8;
  var HEAPU8;
  var HEAP16;
  var HEAPU16;
  var HEAP32;
  var HEAPU32;
  var HEAPF32;
  var HEAPF64;
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    Module["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module["HEAP16"] = HEAP16 = new Int16Array(buf);
    Module["HEAP32"] = HEAP32 = new Int32Array(buf);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }
  var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
  var wasmTable;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATMAIN__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  var runtimeKeepaliveCounter = 0;
  function keepRuntimeAlive() {
    return noExitRuntime || runtimeKeepaliveCounter > 0;
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    callRuntimeCallbacks(__ATINIT__);
  }
  function preMain() {
    callRuntimeCallbacks(__ATMAIN__);
  }
  function exitRuntime() {
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  Module["preloadedImages"] = {};
  Module["preloadedAudios"] = {};
  function abort(what) {
    {
      if (Module["onAbort"]) {
        Module["onAbort"](what);
      }
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -s ASSERTIONS=1 for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  var wasmBinaryFile;
  wasmBinaryFile = "libFourQ.wasm";
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function asciiToBinary(str) {
    if (typeof atob === "function") {
      return atob(str);
    } else {
      return Buffer.from(str, "base64").toString("binary");
    }
  }
  function decode(encoded) {
    var binaryString = asciiToBinary(encoded);
    var bytes = new Uint8Array(binaryString.length);
    for (var i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
  function createWasm() {
    var info = { env: asmLibraryArg, wasi_snapshot_preview1: asmLibraryArg };
    function receiveInstance(instance, module) {
      var exports2 = instance.exports;
      Module["asm"] = exports2;
      wasmMemory = Module["asm"]["memory"];
      updateGlobalBufferAndViews(wasmMemory.buffer);
      wasmTable = Module["asm"]["__indirect_function_table"];
      removeRunDependency("wasm-instantiate");
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    function instantiateArrayBuffer(receiver) {
      return WebAssembly.instantiate(decode(encodedWasmFile), info).then(function(instance) {
        return instance;
      }).then(receiver, function(reason) {
        err("failed to asynchronously prepare wasm: " + reason);
        abort(reason);
      });
    }
    function instantiateAsync() {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
    if (Module["instantiateWasm"]) {
      try {
        var exports = Module["instantiateWasm"](info, receiveInstance);
        return exports;
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        return false;
      }
    }
    instantiateAsync();
    return {};
  }
  var tempDouble;
  var tempI64;
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
        callback(Module);
        continue;
      }
      var func = callback.func;
      if (typeof func === "number") {
        if (callback.arg === void 0) {
          getWasmTableEntry(func)();
        } else {
          getWasmTableEntry(func)(callback.arg);
        }
      } else {
        func(callback.arg === void 0 ? null : callback.arg);
      }
    }
  }
  var wasmTableMirror = [];
  function getWasmTableEntry(funcPtr) {
    var func = wasmTableMirror[funcPtr];
    if (!func) {
      if (funcPtr >= wasmTableMirror.length)
        wasmTableMirror.length = funcPtr + 1;
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
    }
    return func;
  }
  function handleException(e) {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  }
  var PATH = {
    splitPath: function(filename) {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: function(parts, allowAboveRoot) {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: function(path) {
      var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter(function(p) {
        return !!p;
      }), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: function(path) {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: function(path) {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    extname: function(path) {
      return PATH.splitPath(path)[3];
    },
    join: function() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return PATH.normalize(paths.join("/"));
    },
    join2: function(l, r) {
      return PATH.normalize(l + "/" + r);
    }
  };
  function getRandomDevice() {
    if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
      var randomBuffer = new Uint8Array(1);
      return function() {
        crypto.getRandomValues(randomBuffer);
        return randomBuffer[0];
      };
    }
    return function() {
      abort("randomDevice");
    };
  }
  var PATH_FS = {
    resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path !== "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === "/";
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
        return !!p;
      }), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: function(from, to) {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var TTY = {
    ttys: [],
    init: function() {
    },
    shutdown: function() {
    },
    register: function(dev, ops) {
      TTY.ttys[dev] = { input: [], output: [], ops };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close: function(stream) {
        stream.tty.ops.flush(stream.tty);
      },
      flush: function(stream) {
        stream.tty.ops.flush(stream.tty);
      },
      read: function(stream, buffer2, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer2[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer2, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char: function(tty) {
        if (!tty.input.length) {
          var result = null;
          if (ENVIRONMENT_IS_NODE) {
            var BUFSIZE = 256;
            var buf = Buffer.alloc(BUFSIZE);
            var bytesRead = 0;
            try {
              bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
            } catch (e) {
              if (e.toString().includes("EOF"))
                bytesRead = 0;
              else
                throw e;
            }
            if (bytesRead > 0) {
              result = buf.slice(0, bytesRead).toString("utf-8");
            } else {
              result = null;
            }
          } else if (typeof window != "undefined" && typeof window.prompt == "function") {
            result = window.prompt("Input: ");
            if (result !== null) {
              result += "\n";
            }
          } else if (typeof readline == "function") {
            result = readline();
            if (result !== null) {
              result += "\n";
            }
          }
          if (!result) {
            return null;
          }
          tty.input = intArrayFromString(result, true);
        }
        return tty.input.shift();
      },
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      flush: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    },
    default_tty1_ops: {
      put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      flush: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  function mmapAlloc(size) {
    abort();
  }
  var MEMFS = {
    ops_table: null,
    mount: function(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    },
    createNode: function(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: { llseek: MEMFS.stream_ops.llseek }
          },
          file: {
            node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr },
            stream: FS.chrdev_stream_ops
          }
        };
      }
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray: function(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage: function(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage: function(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr: function(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr: function(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup: function(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod: function(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename: function(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
        old_node.parent = new_dir;
      },
      unlink: function(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir: function(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir: function(node) {
        var entries = [".", ".."];
        for (var key2 in node.contents) {
          if (!node.contents.hasOwnProperty(key2)) {
            continue;
          }
          entries.push(key2);
        }
        return entries;
      },
      symlink: function(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink: function(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read: function(stream, buffer2, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer2.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer2[offset + i] = contents[position + i];
        }
        return size;
      },
      write: function(stream, buffer2, offset, length, position, canOwn) {
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer2.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer2.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer2.subarray) {
          node.contents.set(buffer2.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer2[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek: function(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate: function(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap: function(stream, address, length, position, prot, flags) {
        if (address !== 0) {
          throw new FS.ErrnoError(28);
        }
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return { ptr, allocated };
      },
      msync: function(stream, buffer2, offset, length, mmapFlags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (mmapFlags & 2) {
          return 0;
        }
        var bytesWritten = MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
        return 0;
      }
    }
  };
  function asyncLoad(url, onload, onerror, noRunDep) {
    var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
    readAsync(url, function(arrayBuffer) {
      assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, function(event) {
      if (onerror) {
        onerror();
      } else {
        throw 'Loading data file "' + url + '" failed.';
      }
    });
    if (dep)
      addRunDependency(dep);
  }
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    lookupPath: function(path, opts) {
      path = PATH_FS.resolve(FS.cwd(), path);
      opts = opts || {};
      if (!path)
        return { path: "", node: null };
      var defaults = { follow_mount: true, recurse_count: 0 };
      for (var key2 in defaults) {
        if (opts[key2] === void 0) {
          opts[key2] = defaults[key2];
        }
      }
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
        return !!p;
      }), false);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
            current = lookup.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return { path: current_path, node: current };
    },
    getPath: function(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
        }
        path = path ? node.name + "/" + path : node.name;
        node = node.parent;
      }
    },
    hashName: function(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode: function(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode: function(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode: function(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode: function(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode: function(node) {
      FS.hashRemoveNode(node);
    },
    isRoot: function(node) {
      return node === node.parent;
    },
    isMountpoint: function(node) {
      return !!node.mounted;
    },
    isFile: function(mode) {
      return (mode & 61440) === 32768;
    },
    isDir: function(mode) {
      return (mode & 61440) === 16384;
    },
    isLink: function(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev: function(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev: function(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO: function(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket: function(mode) {
      return (mode & 49152) === 49152;
    },
    flagModes: { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 },
    modeStringToFlags: function(str) {
      var flags = FS.flagModes[str];
      if (typeof flags === "undefined") {
        throw new Error("Unknown file open mode: " + str);
      }
      return flags;
    },
    flagsToPermissionString: function(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions: function(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup: function(dir) {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate: function(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete: function(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen: function(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd: function(fd_start, fd_end) {
      fd_start = fd_start || 0;
      fd_end = fd_end || FS.MAX_OPEN_FDS;
      for (var fd = fd_start; fd <= fd_end; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStream: function(fd) {
      return FS.streams[fd];
    },
    createStream: function(stream, fd_start, fd_end) {
      if (!FS.FSStream) {
        FS.FSStream = function() {
        };
        FS.FSStream.prototype = {
          object: {
            get: function() {
              return this.node;
            },
            set: function(val) {
              this.node = val;
            }
          },
          isRead: {
            get: function() {
              return (this.flags & 2097155) !== 1;
            }
          },
          isWrite: {
            get: function() {
              return (this.flags & 2097155) !== 0;
            }
          },
          isAppend: {
            get: function() {
              return this.flags & 1024;
            }
          }
        };
      }
      var newStream = new FS.FSStream();
      for (var p in stream) {
        newStream[p] = stream[p];
      }
      stream = newStream;
      var fd = FS.nextfd(fd_start, fd_end);
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream: function(fd) {
      FS.streams[fd] = null;
    },
    chrdev_stream_ops: {
      open: function(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      },
      llseek: function() {
        throw new FS.ErrnoError(70);
      }
    },
    major: function(dev) {
      return dev >> 8;
    },
    minor: function(dev) {
      return dev & 255;
    },
    makedev: function(ma, mi) {
      return ma << 8 | mi;
    },
    registerDevice: function(dev, ops) {
      FS.devices[dev] = { stream_ops: ops };
    },
    getDevice: function(dev) {
      return FS.devices[dev];
    },
    getMounts: function(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    },
    syncfs: function(populate, callback) {
      if (typeof populate === "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach(function(mount) {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount: function(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        mountpoint = lookup.path;
        node = lookup.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = { type, opts, mountpoint, mounts: [] };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount: function(mountpoint) {
      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
      if (!FS.isMountpoint(lookup.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach(function(hash) {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup: function(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod: function(path, mode, dev) {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create: function(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir: function(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree: function(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev: function(path, mode, dev) {
      if (typeof dev === "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink: function(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup = FS.lookupPath(newpath, { parent: true });
      var parent = lookup.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename: function(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup, old_dir, new_dir;
      lookup = FS.lookupPath(old_path, { parent: true });
      old_dir = lookup.node;
      lookup = FS.lookupPath(new_path, { parent: true });
      new_dir = lookup.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir: function(path) {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir: function(path) {
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink: function(path) {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink: function(path) {
      var lookup = FS.lookupPath(path);
      var link = lookup.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat: function(path, dontFollow) {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      var node = lookup.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat: function(path) {
      return FS.stat(path, true);
    },
    chmod: function(path, mode, dontFollow) {
      var node;
      if (typeof path === "string") {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod: function(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod: function(fd, mode) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      FS.chmod(stream.node, mode);
    },
    chown: function(path, uid, gid, dontFollow) {
      var node;
      if (typeof path === "string") {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, { timestamp: Date.now() });
    },
    lchown: function(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown: function(fd, uid, gid) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      FS.chown(stream.node, uid, gid);
    },
    truncate: function(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path === "string") {
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
    },
    ftruncate: function(fd, len) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime: function(path, atime, mtime) {
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
    },
    open: function(path, flags, mode, fd_start, fd_end) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
      mode = typeof mode === "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path === "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
          node = lookup.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        id: node.id,
        flags,
        mode: node.mode,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        node_ops: node.node_ops,
        ungotten: [],
        error: false
      }, fd_start, fd_end);
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close: function(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed: function(stream) {
      return stream.fd === null;
    },
    llseek: function(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read: function(stream, buffer2, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position !== "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write: function(stream, buffer2, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position !== "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate: function(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap: function(stream, address, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
    },
    msync: function(stream, buffer2, offset, length, mmapFlags) {
      if (!stream || !stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
    },
    munmap: function(stream) {
      return 0;
    },
    ioctl: function(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile: function(path, opts) {
      opts = opts || {};
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error('Invalid encoding type "' + opts.encoding + '"');
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile: function(path, data, opts) {
      opts = opts || {};
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data === "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: function() {
      return FS.currentPath;
    },
    chdir: function(path) {
      var lookup = FS.lookupPath(path, { follow: true });
      if (lookup.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup.path;
    },
    createDefaultDirectories: function() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices: function() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: function() {
          return 0;
        },
        write: function(stream, buffer2, offset, length, pos) {
          return length;
        }
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var random_device = getRandomDevice();
      FS.createDevice("/dev", "random", random_device);
      FS.createDevice("/dev", "urandom", random_device);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories: function() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount: function() {
          var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: function(parent, name) {
              var fd = +name;
              var stream = FS.getStream(fd);
              if (!stream)
                throw new FS.ErrnoError(8);
              var ret = {
                parent: null,
                mount: { mountpoint: "fake" },
                node_ops: {
                  readlink: function() {
                    return stream.path;
                  }
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams: function() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    ensureErrnoError: function() {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
        };
        this.setErrno(errno);
        this.message = "FS error";
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach(function(code) {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    },
    staticInit: function() {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = { MEMFS };
    },
    init: function(input, output, error) {
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit: function() {
      FS.init.initialized = false;
      var fflush = Module["_fflush"];
      if (fflush)
        fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    getMode: function(canRead, canWrite) {
      var mode = 0;
      if (canRead)
        mode |= 292 | 73;
      if (canWrite)
        mode |= 146;
      return mode;
    },
    findObject: function(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (ret.exists) {
        return ret.object;
      } else {
        return null;
      }
    },
    analyzePath: function(path, dontResolveLastLink) {
      try {
        var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
        path = lookup.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup = FS.lookupPath(path, { parent: true });
        ret.parentExists = true;
        ret.parentPath = lookup.path;
        ret.parentObject = lookup.node;
        ret.name = PATH.basename(path);
        lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
        ret.exists = true;
        ret.path = lookup.path;
        ret.object = lookup.node;
        ret.name = lookup.node.name;
        ret.isRoot = lookup.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath: function(parent, path, canRead, canWrite) {
      parent = typeof parent === "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile: function(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
      var mode = FS.getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile: function(parent, name, data, canRead, canWrite, canOwn) {
      var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
      var mode = FS.getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data === "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    },
    createDevice: function(parent, name, input, output) {
      var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
      var mode = FS.getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open: function(stream) {
          stream.seekable = false;
        },
        close: function(stream) {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        },
        read: function(stream, buffer2, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: function(stream, buffer2, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer2[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile: function(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest !== "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile: function(parent, name, url, canRead, canWrite) {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = function(from, to) {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          if (typeof Uint8Array != "undefined")
            xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          } else {
            return intArrayFromString(xhr2.responseText || "", true);
          }
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter(function(chunkNum) {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] === "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest !== "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, {
          length: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            }
          },
          chunkSize: {
            get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            }
          }
        });
        var properties = { isDevice: false, contents: lazyArray };
      } else {
        var properties = { isDevice: false, url };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach(function(key2) {
        var fn = node.stream_ops[key2];
        stream_ops[key2] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
        FS.forceLoadFile(node);
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer2[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer2[offset + i] = contents.get(position + i);
          }
        }
        return size;
      };
      node.stream_ops = stream_ops;
      return node;
    },
    createPreloadedFile: function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
      Browser.init();
      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
      var dep = getUniqueRunDependency("cp " + fullname);
      function processData(byteArray) {
        function finish(byteArray2) {
          if (preFinish)
            preFinish();
          if (!dontCreateFile) {
            FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
          }
          if (onload)
            onload();
          removeRunDependency(dep);
        }
        var handled = false;
        Module["preloadPlugins"].forEach(function(plugin) {
          if (handled)
            return;
          if (plugin["canHandle"](fullname)) {
            plugin["handle"](byteArray, fullname, finish, function() {
              if (onerror)
                onerror();
              removeRunDependency(dep);
            });
            handled = true;
          }
        });
        if (!handled)
          finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == "string") {
        asyncLoad(url, function(byteArray) {
          processData(byteArray);
        }, onerror);
      } else {
        processData(url);
      }
    },
    indexedDB: function() {
      return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
    },
    DB_NAME: function() {
      return "EM_FS_" + window.location.pathname;
    },
    DB_VERSION: 20,
    DB_STORE_NAME: "FILE_DATA",
    saveFilesToDB: function(paths, onload, onerror) {
      onload = onload || function() {
      };
      onerror = onerror || function() {
      };
      var indexedDB = FS.indexedDB();
      try {
        var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
      } catch (e) {
        return onerror(e);
      }
      openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
        out("creating db");
        var db = openRequest.result;
        db.createObjectStore(FS.DB_STORE_NAME);
      };
      openRequest.onsuccess = function openRequest_onsuccess() {
        var db = openRequest.result;
        var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
        var files = transaction.objectStore(FS.DB_STORE_NAME);
        var ok = 0, fail = 0, total = paths.length;
        function finish() {
          if (fail == 0)
            onload();
          else
            onerror();
        }
        paths.forEach(function(path) {
          var putRequest = files.put(FS.analyzePath(path).object.contents, path);
          putRequest.onsuccess = function putRequest_onsuccess() {
            ok++;
            if (ok + fail == total)
              finish();
          };
          putRequest.onerror = function putRequest_onerror() {
            fail++;
            if (ok + fail == total)
              finish();
          };
        });
        transaction.onerror = onerror;
      };
      openRequest.onerror = onerror;
    },
    loadFilesFromDB: function(paths, onload, onerror) {
      onload = onload || function() {
      };
      onerror = onerror || function() {
      };
      var indexedDB = FS.indexedDB();
      try {
        var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
      } catch (e) {
        return onerror(e);
      }
      openRequest.onupgradeneeded = onerror;
      openRequest.onsuccess = function openRequest_onsuccess() {
        var db = openRequest.result;
        try {
          var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
        } catch (e) {
          onerror(e);
          return;
        }
        var files = transaction.objectStore(FS.DB_STORE_NAME);
        var ok = 0, fail = 0, total = paths.length;
        function finish() {
          if (fail == 0)
            onload();
          else
            onerror();
        }
        paths.forEach(function(path) {
          var getRequest = files.get(path);
          getRequest.onsuccess = function getRequest_onsuccess() {
            if (FS.analyzePath(path).exists) {
              FS.unlink(path);
            }
            FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
            ok++;
            if (ok + fail == total)
              finish();
          };
          getRequest.onerror = function getRequest_onerror() {
            fail++;
            if (ok + fail == total)
              finish();
          };
        });
        transaction.onerror = onerror;
      };
      openRequest.onerror = onerror;
    }
  };
  var SYSCALLS = {
    mappings: {},
    DEFAULT_POLLMASK: 5,
    calculateAt: function(dirfd, path, allowEmpty) {
      if (path[0] === "/") {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = FS.getStream(dirfd);
        if (!dirstream)
          throw new FS.ErrnoError(8);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = 0;
      HEAP32[buf + 8 >> 2] = stat.ino;
      HEAP32[buf + 12 >> 2] = stat.mode;
      HEAP32[buf + 16 >> 2] = stat.nlink;
      HEAP32[buf + 20 >> 2] = stat.uid;
      HEAP32[buf + 24 >> 2] = stat.gid;
      HEAP32[buf + 28 >> 2] = stat.rdev;
      HEAP32[buf + 32 >> 2] = 0;
      tempI64 = [
        stat.size >>> 0,
        (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)
      ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAP32[buf + 48 >> 2] = 4096;
      HEAP32[buf + 52 >> 2] = stat.blocks;
      HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
      HEAP32[buf + 60 >> 2] = 0;
      HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
      HEAP32[buf + 68 >> 2] = 0;
      HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
      HEAP32[buf + 76 >> 2] = 0;
      tempI64 = [
        stat.ino >>> 0,
        (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)
      ], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];
      return 0;
    },
    doMsync: function(addr, stream, len, flags, offset) {
      var buffer2 = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer2, offset, len, flags);
    },
    doMkdir: function(path, mode) {
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    },
    doMknod: function(path, mode, dev) {
      switch (mode & 61440) {
        case 32768:
        case 8192:
        case 24576:
        case 4096:
        case 49152:
          break;
        default:
          return -28;
      }
      FS.mknod(path, mode, dev);
      return 0;
    },
    doReadlink: function(path, buf, bufsize) {
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    },
    doAccess: function(path, amode) {
      if (amode & ~7) {
        return -28;
      }
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    },
    doDup: function(path, flags, suggestFD) {
      var suggest = FS.getStream(suggestFD);
      if (suggest)
        FS.close(suggest);
      return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
    },
    doReadv: function(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAP32[iov + i * 8 >> 2];
        var len = HEAP32[iov + (i * 8 + 4) >> 2];
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len)
          break;
      }
      return ret;
    },
    doWritev: function(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAP32[iov + i * 8 >> 2];
        var len = HEAP32[iov + (i * 8 + 4) >> 2];
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
      }
      return ret;
    },
    varargs: void 0,
    get: function() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr: function(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    },
    getStreamFromFD: function(fd) {
      var stream = FS.getStream(fd);
      if (!stream)
        throw new FS.ErrnoError(8);
      return stream;
    },
    get64: function(low, high) {
      return low;
    }
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
        throw e;
      return e.errno;
    }
  }
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doReadv(stream, iov, iovcnt);
      HEAP32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 4294967296;
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
      var DOUBLE_LIMIT = 9007199254740992;
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
      FS.llseek(stream, offset, whence);
      tempI64 = [
        stream.position >>> 0,
        (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)
      ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
        throw e;
      return e.errno;
    }
  }
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
        throw e;
      return e.errno;
    }
  }
  function _proc_exit(code) {
    procExit(code);
  }
  var FSNode = function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
    read: {
      get: function() {
        return (this.mode & readMode) === readMode;
      },
      set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }
    },
    write: {
      get: function() {
        return (this.mode & writeMode) === writeMode;
      },
      set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }
    },
    isFolder: {
      get: function() {
        return FS.isDir(this.mode);
      }
    },
    isDevice: {
      get: function() {
        return FS.isChrdev(this.mode);
      }
    }
  });
  FS.FSNode = FSNode;
  FS.staticInit();
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var asmLibraryArg = {
    fd_close: _fd_close,
    fd_read: _fd_read,
    fd_seek: _fd_seek,
    fd_write: _fd_write,
    proc_exit: _proc_exit
  };
  var asm = createWasm();
  var _SchnorrQ_KeyGeneration = Module["_SchnorrQ_KeyGeneration"] = function() {
    return (_SchnorrQ_KeyGeneration = Module["_SchnorrQ_KeyGeneration"] = Module["asm"]["SchnorrQ_KeyGeneration"]).apply(null, arguments);
  };
  var _KangarooTwelve = Module["_KangarooTwelve"] = function() {
    return (_KangarooTwelve = Module["_KangarooTwelve"] = Module["asm"]["KangarooTwelve"]).apply(null, arguments);
  };
  var _SchnorrQ_Sign = Module["_SchnorrQ_Sign"] = function() {
    return (_SchnorrQ_Sign = Module["_SchnorrQ_Sign"] = Module["asm"]["SchnorrQ_Sign"]).apply(null, arguments);
  };
  var _free = Module["_free"] = function() {
    return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
  };
  var _SchnorrQ_Verify = Module["_SchnorrQ_Verify"] = function() {
    return (_SchnorrQ_Verify = Module["_SchnorrQ_Verify"] = Module["asm"]["SchnorrQ_Verify"]).apply(null, arguments);
  };
  var _CompressedPublicKeyGeneration = Module["_CompressedPublicKeyGeneration"] = function() {
    return (_CompressedPublicKeyGeneration = Module["_CompressedPublicKeyGeneration"] = Module["asm"]["CompressedPublicKeyGeneration"]).apply(null, arguments);
  };
  var _CompressedKeyGeneration = Module["_CompressedKeyGeneration"] = function() {
    return (_CompressedKeyGeneration = Module["_CompressedKeyGeneration"] = Module["asm"]["CompressedKeyGeneration"]).apply(null, arguments);
  };
  var _CompressedSecretAgreement = Module["_CompressedSecretAgreement"] = function() {
    return (_CompressedSecretAgreement = Module["_CompressedSecretAgreement"] = Module["asm"]["CompressedSecretAgreement"]).apply(null, arguments);
  };
  var _PublicKeyGeneration = Module["_PublicKeyGeneration"] = function() {
    return (_PublicKeyGeneration = Module["_PublicKeyGeneration"] = Module["asm"]["PublicKeyGeneration"]).apply(null, arguments);
  };
  var _KeyGeneration = Module["_KeyGeneration"] = function() {
    return (_KeyGeneration = Module["_KeyGeneration"] = Module["asm"]["KeyGeneration"]).apply(null, arguments);
  };
  var _SecretAgreement = Module["_SecretAgreement"] = function() {
    return (_SecretAgreement = Module["_SecretAgreement"] = Module["asm"]["SecretAgreement"]).apply(null, arguments);
  };
  var __initialize = Module["__initialize"] = function() {
    return (__initialize = Module["__initialize"] = Module["asm"]["_initialize"]).apply(null, arguments);
  };
  var _malloc = Module["_malloc"] = function() {
    return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
  };
  var calledRun;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status;
  }
  var calledMain = false;
  var mainArgs = void 0;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function callMain(args) {
    var entryFunction = Module["__initialize"];
    mainArgs = [thisProgram].concat(args);
    try {
      entryFunction();
      var ret = 0;
      exit(ret, true);
      return ret;
    } catch (e) {
      return handleException(e);
    } finally {
      calledMain = true;
    }
  }
  function run(args) {
    args = args || arguments_;
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      preMain();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      if (shouldRunNow)
        callMain(args);
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  Module["run"] = run;
  function exit(status, implicit) {
    EXITSTATUS = status;
    if (keepRuntimeAlive()) {
    } else {
      exitRuntime();
    }
    procExit(status);
  }
  function procExit(code) {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      if (Module["onExit"])
        Module["onExit"](code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  var shouldRunNow = true;
  if (Module["noInitialRun"])
    shouldRunNow = false;
  run();
  var libFourQ_K12_default = Module;

  // dist/crypto/keccakp.js
  var U32_MASK64 = BigInt(2 ** 32 - 1);
  var _32n = BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  var shrSH = (h, l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H = (h, l) => l;
  var rotr32L = (h, l) => h;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _7n = BigInt(7);
  var _256n = BigInt(256);
  var _0x71n = BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);
  function keccakP160012(s1) {
    const s = new Uint32Array(s1.buffer);
    const rounds = 12;
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }

  // dist/crypto/index.js
  var allocU8 = function(l, v) {
    let ptr = libFourQ_K12_default._malloc(l);
    let chunk = libFourQ_K12_default.HEAPU8.subarray(ptr, ptr + l);
    if (v) {
      chunk.set(v);
    }
    return chunk;
  };
  var allocU16 = function(l, v) {
    let ptr = libFourQ_K12_default._malloc(l);
    let chunk = libFourQ_K12_default.HEAPU16.subarray(ptr, ptr + l);
    chunk.set(v);
    return chunk;
  };
  var crypto2 = new Promise(function(resolve) {
    libFourQ_K12_default.onRuntimeInitialized = function() {
      const generatePublicKey = function(secretKey) {
        const sk = allocU8(secretKey.length, secretKey);
        const pk = allocU8(32);
        const free = function() {
          libFourQ_K12_default._free(sk.byteOffset);
          libFourQ_K12_default._free(pk.byteOffset);
        };
        libFourQ_K12_default._SchnorrQ_KeyGeneration(sk.byteOffset, pk.byteOffset);
        const key2 = pk.slice();
        free();
        return key2;
      };
      const sign = function(secretKey, publicKey, message) {
        const sk = allocU8(secretKey.length, secretKey);
        const pk = allocU8(publicKey.length, publicKey);
        const m = allocU8(message.length, message);
        const s = allocU8(64);
        const free = function() {
          libFourQ_K12_default._free(sk.byteOffset);
          libFourQ_K12_default._free(pk.byteOffset);
          libFourQ_K12_default._free(m.byteOffset);
          libFourQ_K12_default._free(s.byteOffset);
        };
        libFourQ_K12_default._SchnorrQ_Sign(sk.byteOffset, pk.byteOffset, m.byteOffset, message.length, s.byteOffset);
        const sig = s.slice();
        free();
        return sig;
      };
      const verify = function(publicKey, message, signature) {
        const pk = allocU8(publicKey.length, publicKey);
        const m = allocU8(message.length, message);
        const s = allocU8(signature.length, signature);
        const v = allocU16(1, new Uint16Array(1));
        const free = function() {
          libFourQ_K12_default._free(pk.byteOffset);
          libFourQ_K12_default._free(m.byteOffset);
          libFourQ_K12_default._free(s.byteOffset);
          libFourQ_K12_default._free(v.byteOffset);
        };
        libFourQ_K12_default._SchnorrQ_Verify(pk.byteOffset, m.byteOffset, message.length, s.byteOffset, v.byteOffset);
        const ver = v[0];
        free();
        return ver;
      };
      const generateCompressedPublicKey = function(secretKey) {
        const sk = allocU8(secretKey.length, secretKey);
        const pk = allocU8(32);
        const free = function() {
          libFourQ_K12_default._free(sk.byteOffset);
          libFourQ_K12_default._free(pk.byteOffset);
        };
        libFourQ_K12_default._CompressedPublicKeyGeneration(sk.byteOffset, pk.byteOffset);
        const key2 = pk.slice();
        free();
        return key2;
      };
      const compressedSecretAgreement = function(secretKey, publicKey) {
        const sk = allocU8(secretKey.length, secretKey);
        const pk = allocU8(publicKey.length, publicKey);
        const shk = allocU8(32);
        const free = function() {
          libFourQ_K12_default._free(sk.byteOffset);
          libFourQ_K12_default._free(pk.byteOffset);
          libFourQ_K12_default._free(shk.byteOffset);
        };
        libFourQ_K12_default._CompressedSecretAgreement(sk.byteOffset, pk.byteOffset, shk.byteOffset);
        const key2 = shk.slice();
        free();
        return key2;
      };
      const K12 = function(input, output, outputLength, outputOffset = 0) {
        const i = allocU8(input.length, input);
        const o = allocU8(outputLength, new Uint8Array(outputLength));
        const free = function() {
          libFourQ_K12_default._free(i.byteOffset);
          libFourQ_K12_default._free(o.byteOffset);
        };
        libFourQ_K12_default._KangarooTwelve(i.byteOffset, input.length, o.byteOffset, outputLength, 0, 0);
        output.set(o.slice(), outputOffset);
        free();
      };
      resolve({
        /**
         * @namespace Crypto.schnorrq
         */
        schnorrq: {
          generatePublicKey,
          sign,
          verify
        },
        /**
         * @namespace Crypto.kex
         */
        kex: {
          generateCompressedPublicKey,
          compressedSecretAgreement
        },
        K12,
        keccakP160012,
        KECCAK_STATE_LENGTH: 200
      });
    };
  });
  crypto2.keccakP160012 = keccakP160012;
  var crypto_default = crypto2;

  // dist/converter/converter.js
  var publicKeyStringToBytes = function(s) {
    const publicKeyBytes = new Uint8Array(32);
    const view = new DataView(publicKeyBytes.buffer, 0);
    for (let i = 0; i < 4; i++) {
      view.setBigUint64(i * 8, 0n, true);
      for (let j = 14; j-- > 0; ) {
        view.setBigUint64(i * 8, view.getBigUint64(i * 8, true) * 26n + BigInt(s.charCodeAt(i * 14 + j)) - BigInt("A".charCodeAt(0)), true);
      }
    }
    return publicKeyBytes;
  };

  // node_modules/bignumber.js/bignumber.mjs
  var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
  var mathceil = Math.ceil;
  var mathfloor = Math.floor;
  var bignumberError = "[BigNumber Error] ";
  var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
  var BASE = 1e14;
  var LOG_BASE = 14;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
  var SQRT_BASE = 1e7;
  var MAX = 1e9;
  function clone(configObject) {
    var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: "\xA0",
      // non-breaking space
      suffix: ""
    }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
    function BigNumber2(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
      if (!(x instanceof BigNumber2))
        return new BigNumber2(v, b);
      if (b == null) {
        if (v && v._isBigNumber === true) {
          x.s = v.s;
          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }
          return;
        }
        if ((isNum = typeof v == "number") && v * 0 == 0) {
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++)
              ;
            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }
            return;
          }
          str = String(v);
        } else {
          if (!isNumeric.test(str = String(v)))
            return parseNumeric(x, str, isNum);
          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }
        if ((e = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber2(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }
        str = String(v);
        if (isNum = typeof v == "number") {
          if (v * 0 != 0)
            return parseNumeric(x, str, isNum, b);
          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
          if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
            throw Error(tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }
        alphabet = ALPHABET.slice(0, b);
        e = i = 0;
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == ".") {
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }
            return parseNumeric(x, String(v), isNum, b);
          }
        }
        isNum = false;
        str = convertBase(str, b, 10, x.s);
        if ((e = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        else
          e = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; i++)
        ;
      for (len = str.length; str.charCodeAt(--len) === 48; )
        ;
      if (str = str.slice(i, ++len)) {
        len -= i;
        if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error(tooManyDigits + x.s * v);
        }
        if ((e = e - i - 1) > MAX_EXP) {
          x.c = x.e = null;
        } else if (e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0)
            i += LOG_BASE;
          if (i < len) {
            if (i)
              x.c.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; ) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }
            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }
          for (; i--; str += "0")
            ;
          x.c.push(+str);
        }
      } else {
        x.c = [x.e = 0];
      }
    }
    BigNumber2.clone = clone;
    BigNumber2.ROUND_UP = 0;
    BigNumber2.ROUND_DOWN = 1;
    BigNumber2.ROUND_CEIL = 2;
    BigNumber2.ROUND_FLOOR = 3;
    BigNumber2.ROUND_HALF_UP = 4;
    BigNumber2.ROUND_HALF_DOWN = 5;
    BigNumber2.ROUND_HALF_EVEN = 6;
    BigNumber2.ROUND_HALF_CEIL = 7;
    BigNumber2.ROUND_HALF_FLOOR = 8;
    BigNumber2.EUCLID = 9;
    BigNumber2.config = BigNumber2.set = function(obj) {
      var p, v;
      if (obj != null) {
        if (typeof obj == "object") {
          if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }
          if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }
          if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }
          if (obj.hasOwnProperty(p = "RANGE")) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error(bignumberError + p + " cannot be zero: " + v);
              }
            }
          }
          if (obj.hasOwnProperty(p = "CRYPTO")) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error(bignumberError + "crypto unavailable");
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error(bignumberError + p + " not true or false: " + v);
            }
          }
          if (obj.hasOwnProperty(p = "MODULO_MODE")) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }
          if (obj.hasOwnProperty(p = "POW_PRECISION")) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }
          if (obj.hasOwnProperty(p = "FORMAT")) {
            v = obj[p];
            if (typeof v == "object")
              FORMAT = v;
            else
              throw Error(bignumberError + p + " not an object: " + v);
          }
          if (obj.hasOwnProperty(p = "ALPHABET")) {
            v = obj[p];
            if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
              ALPHABET = v;
            } else {
              throw Error(bignumberError + p + " invalid: " + v);
            }
          }
        } else {
          throw Error(bignumberError + "Object expected: " + obj);
        }
      }
      return {
        DECIMAL_PLACES,
        ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO,
        MODULO_MODE,
        POW_PRECISION,
        FORMAT,
        ALPHABET
      };
    };
    BigNumber2.isBigNumber = function(v) {
      if (!v || v._isBigNumber !== true)
        return false;
      if (!BigNumber2.DEBUG)
        return true;
      var i, n, c = v.c, e = v.e, s = v.s;
      out:
        if ({}.toString.call(c) == "[object Array]") {
          if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
            if (c[0] === 0) {
              if (e === 0 && c.length === 1)
                return true;
              break out;
            }
            i = (e + 1) % LOG_BASE;
            if (i < 1)
              i += LOG_BASE;
            if (String(c[0]).length == i) {
              for (i = 0; i < c.length; i++) {
                n = c[i];
                if (n < 0 || n >= BASE || n !== mathfloor(n))
                  break out;
              }
              if (n !== 0)
                return true;
            }
          }
        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
          return true;
        }
      throw Error(bignumberError + "Invalid BigNumber: " + v);
    };
    BigNumber2.maximum = BigNumber2.max = function() {
      return maxOrMin(arguments, -1);
    };
    BigNumber2.minimum = BigNumber2.min = function() {
      return maxOrMin(arguments, 1);
    };
    BigNumber2.random = function() {
      var pow2_53 = 9007199254740992;
      var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
        return mathfloor(Math.random() * pow2_53);
      } : function() {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
      };
      return function(dp) {
        var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
        if (dp == null)
          dp = DECIMAL_PLACES;
        else
          intCheck(dp, 0, MAX);
        k = mathceil(dp / LOG_BASE);
        if (CRYPTO) {
          if (crypto.getRandomValues) {
            a = crypto.getRandomValues(new Uint32Array(k *= 2));
            for (; i < k; ) {
              v = a[i] * 131072 + (a[i + 1] >>> 11);
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;
          } else if (crypto.randomBytes) {
            a = crypto.randomBytes(k *= 7);
            for (; i < k; ) {
              v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + "crypto unavailable");
          }
        }
        if (!CRYPTO) {
          for (; i < k; ) {
            v = random53bitInt();
            if (v < 9e15)
              c[i++] = v % 1e14;
          }
        }
        k = c[--i];
        dp %= LOG_BASE;
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }
        for (; c[i] === 0; c.pop(), i--)
          ;
        if (i < 0) {
          c = [e = 0];
        } else {
          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
            ;
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
            ;
          if (i < LOG_BASE)
            e -= LOG_BASE - i;
        }
        rand.e = e;
        rand.c = c;
        return rand;
      };
    }();
    BigNumber2.sum = function() {
      var i = 1, args = arguments, sum = new BigNumber2(args[0]);
      for (; i < args.length; )
        sum = sum.plus(args[i++]);
      return sum;
    };
    convertBase = function() {
      var decimal = "0123456789";
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j, arr = [0], arrL, i = 0, len = str.length;
        for (; i < len; ) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
            ;
          arr[0] += alphabet.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null)
                arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      return function(str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
        if (i >= 0) {
          k = POW_PRECISION;
          POW_PRECISION = 0;
          str = str.replace(".", "");
          y = new BigNumber2(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;
          y.c = toBaseOut(
            toFixedPoint(coeffToString(x.c), x.e, "0"),
            10,
            baseOut,
            decimal
          );
          y.e = y.c.length;
        }
        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
        e = k = xc.length;
        for (; xc[--k] == 0; xc.pop())
          ;
        if (!xc[0])
          return alphabet.charAt(0);
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }
        d = e + dp + 1;
        i = xc[d];
        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;
        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
        if (d < 1 || !xc[0]) {
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {
          xc.length = d;
          if (r) {
            for (--baseOut; ++xc[--d] > baseOut; ) {
              xc[d] = 0;
              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }
          for (k = xc.length; !xc[--k]; )
            ;
          for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
            ;
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }
        return str;
      };
    }();
    div = function() {
      function multiply(x, k, base) {
        var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
        for (x = x.slice(); i--; ) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }
        if (carry)
          x = [carry].concat(x);
        return x;
      }
      function compare2(a, b, aL, bL) {
        var i, cmp;
        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {
          for (i = cmp = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return cmp;
      }
      function subtract(a, b, aL, base) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; a.splice(0, 1))
          ;
      }
      return function(x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
        if (!xc || !xc[0] || !yc || !yc[0]) {
          return new BigNumber2(
            // Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
              // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
              xc && xc[0] == 0 || !yc ? s * 0 : s / 0
            )
          );
        }
        q = new BigNumber2(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;
        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }
        for (i = 0; yc[i] == (xc[i] || 0); i++)
          ;
        if (yc[i] > (xc[i] || 0))
          e--;
        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;
          n = mathfloor(base / (yc[0] + 1));
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }
          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; rem[remL++] = 0)
            ;
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2)
            yc0++;
          do {
            n = 0;
            cmp = compare2(yc, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * base + (rem[1] || 0);
              n = mathfloor(rem0 / yc0);
              if (n > 1) {
                if (n >= base)
                  n = base - 1;
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;
                while (compare2(prod, rem, prodL, remL) == 1) {
                  n--;
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {
                if (n == 0) {
                  cmp = n = 1;
                }
                prod = yc.slice();
                prodL = prod.length;
              }
              if (prodL < remL)
                prod = [0].concat(prod);
              subtract(rem, prod, remL, base);
              remL = rem.length;
              if (cmp == -1) {
                while (compare2(yc, rem, yL, remL) < 1) {
                  n++;
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            }
            qc[i++] = n;
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);
          more = rem[0] != null;
          if (!qc[0])
            qc.splice(0, 1);
        }
        if (base == BASE) {
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
            ;
          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
        } else {
          q.e = e;
          q.r = +more;
        }
        return q;
      };
    }();
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      if (!n.c)
        return n.toString();
      c0 = n.c[0];
      ne = n.e;
      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
      } else {
        n = round(new BigNumber2(n), i, rm);
        e = n.e;
        str = coeffToString(n.c);
        len = str.length;
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
          for (; len < i; str += "0", len++)
            ;
          str = toExponential(str, e);
        } else {
          i -= ne;
          str = toFixedPoint(str, e, "0");
          if (e + 1 > len) {
            if (--i > 0)
              for (str += "."; i--; str += "0")
                ;
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len)
                str += ".";
              for (; i--; str += "0")
                ;
            }
          }
        }
      }
      return n.s < 0 && c0 ? "-" + str : str;
    }
    function maxOrMin(args, n) {
      var k, y, i = 1, x = new BigNumber2(args[0]);
      for (; i < args.length; i++) {
        y = new BigNumber2(args[i]);
        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
          x = y;
        }
      }
      return x;
    }
    function normalise(n, c, e) {
      var i = 1, j = c.length;
      for (; !c[--j]; c.pop())
        ;
      for (j = c[0]; j >= 10; j /= 10, i++)
        ;
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
        n.c = n.e = null;
      } else if (e < MIN_EXP) {
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }
      return n;
    }
    parseNumeric = function() {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function(x, str, isNum, b) {
        var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {
            s = s.replace(basePrefix, function(m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
              return !b || b == base ? p1 : m;
            });
            if (b) {
              base = b;
              s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
            }
            if (str != s)
              return new BigNumber2(s, base);
          }
          if (BigNumber2.DEBUG) {
            throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
          }
          x.s = null;
        }
        x.c = x.e = null;
      };
    }();
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
      if (xc) {
        out: {
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
            ;
          i = sd - d;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];
            rd = mathfloor(n / pows10[d - j - 1] % 10);
          } else {
            ni = mathceil((i + 1) / LOG_BASE);
            if (ni >= xc.length) {
              if (r) {
                for (; xc.length <= ni; xc.push(0))
                  ;
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];
              for (d = 1; k >= 10; k /= 10, d++)
                ;
              i %= LOG_BASE;
              j = i - LOG_BASE + d;
              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
            }
          }
          r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xc[0]) {
            xc.length = 0;
            if (r) {
              sd -= x.e + 1;
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {
              xc[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }
          if (r) {
            for (; ; ) {
              if (ni == 0) {
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                  ;
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++)
                  ;
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE)
                    xc[0] = 1;
                }
                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE)
                  break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }
          for (i = xc.length; xc[--i] === 0; xc.pop())
            ;
        }
        if (x.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }
      return x;
    }
    function valueOf(n) {
      var str, e = n.e;
      if (e === null)
        return n.toString();
      str = coeffToString(n.c);
      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
      return n.s < 0 ? "-" + str : str;
    }
    P.absoluteValue = P.abs = function() {
      var x = new BigNumber2(this);
      if (x.s < 0)
        x.s = 1;
      return x;
    };
    P.comparedTo = function(y, b) {
      return compare(this, new BigNumber2(y, b));
    };
    P.decimalPlaces = P.dp = function(dp, rm) {
      var c, n, v, x = this;
      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(new BigNumber2(x), dp + x.e + 1, rm);
      }
      if (!(c = x.c))
        return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
      if (v = c[v])
        for (; v % 10 == 0; v /= 10, n--)
          ;
      if (n < 0)
        n = 0;
      return n;
    };
    P.dividedBy = P.div = function(y, b) {
      return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };
    P.dividedToIntegerBy = P.idiv = function(y, b) {
      return div(this, new BigNumber2(y, b), 0, 1);
    };
    P.exponentiatedBy = P.pow = function(n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
      n = new BigNumber2(n);
      if (n.c && !n.isInteger()) {
        throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
      }
      if (m != null)
        m = new BigNumber2(m);
      nIsBig = n.e > 14;
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
        y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }
      nIsNeg = n.s < 0;
      if (m) {
        if (m.c ? !m.c[0] : !m.s)
          return new BigNumber2(NaN);
        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
        if (isModExp)
          x = x.mod(m);
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
        k = x.s < 0 && isOdd(n) ? -0 : 0;
        if (x.e > -1)
          k = 1 / k;
        return new BigNumber2(nIsNeg ? 1 / k : k);
      } else if (POW_PRECISION) {
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }
      if (nIsBig) {
        half = new BigNumber2(0.5);
        if (nIsNeg)
          n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }
      y = new BigNumber2(ONE);
      for (; ; ) {
        if (nIsOdd) {
          y = y.times(x);
          if (!y.c)
            break;
          if (k) {
            if (y.c.length > k)
              y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);
          }
        }
        if (i) {
          i = mathfloor(i / 2);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);
          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          }
        }
        x = x.times(x);
        if (k) {
          if (x.c && x.c.length > k)
            x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);
        }
      }
      if (isModExp)
        return y;
      if (nIsNeg)
        y = ONE.div(y);
      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };
    P.integerValue = function(rm) {
      var n = new BigNumber2(this);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };
    P.isEqualTo = P.eq = function(y, b) {
      return compare(this, new BigNumber2(y, b)) === 0;
    };
    P.isFinite = function() {
      return !!this.c;
    };
    P.isGreaterThan = P.gt = function(y, b) {
      return compare(this, new BigNumber2(y, b)) > 0;
    };
    P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
      return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
    };
    P.isInteger = function() {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };
    P.isLessThan = P.lt = function(y, b) {
      return compare(this, new BigNumber2(y, b)) < 0;
    };
    P.isLessThanOrEqualTo = P.lte = function(y, b) {
      return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
    };
    P.isNaN = function() {
      return !this.s;
    };
    P.isNegative = function() {
      return this.s < 0;
    };
    P.isPositive = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return !!this.c && this.c[0] == 0;
    };
    P.minus = function(y, b) {
      var i, j, t, xLTy, x = this, a = x.s;
      y = new BigNumber2(y, b);
      b = y.s;
      if (!a || !b)
        return new BigNumber2(NaN);
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }
      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
      if (!xe || !ye) {
        if (!xc || !yc)
          return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
        if (!xc[0] || !yc[0]) {
          return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
            // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
            ROUNDING_MODE == 3 ? -0 : 0
          ));
        }
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();
      if (a = xe - ye) {
        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }
        t.reverse();
        for (b = a; b--; t.push(0))
          ;
        t.reverse();
      } else {
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }
      b = (j = yc.length) - (i = xc.length);
      if (b > 0)
        for (; b--; xc[i++] = 0)
          ;
      b = BASE - 1;
      for (; j > a; ) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b)
            ;
          --xc[i];
          xc[j] += BASE;
        }
        xc[j] -= yc[j];
      }
      for (; xc[0] == 0; xc.splice(0, 1), --ye)
        ;
      if (!xc[0]) {
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }
      return normalise(y, xc, ye);
    };
    P.modulo = P.mod = function(y, b) {
      var q, s, x = this;
      y = new BigNumber2(y, b);
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber2(NaN);
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber2(x);
      }
      if (MODULO_MODE == 9) {
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }
      y = x.minus(q.times(y));
      if (!y.c[0] && MODULO_MODE == 1)
        y.s = x.s;
      return y;
    };
    P.multipliedBy = P.times = function(y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
      if (!xc || !yc || !xc[0] || !yc[0]) {
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;
          if (!xc || !yc) {
            y.c = y.e = null;
          } else {
            y.c = [0];
            y.e = 0;
          }
        }
        return y;
      }
      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }
      for (i = xcL + ycL, zc = []; i--; zc.push(0))
        ;
      base = BASE;
      sqrtBase = SQRT_BASE;
      for (i = ycL; --i >= 0; ) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;
        for (k = xcL, j = i + k; j > i; ) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }
        zc[j] = c;
      }
      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }
      return normalise(y, zc, e);
    };
    P.negated = function() {
      var x = new BigNumber2(this);
      x.s = -x.s || null;
      return x;
    };
    P.plus = function(y, b) {
      var t, x = this, a = x.s;
      y = new BigNumber2(y, b);
      b = y.s;
      if (!a || !b)
        return new BigNumber2(NaN);
      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }
      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
      if (!xe || !ye) {
        if (!xc || !yc)
          return new BigNumber2(a / 0);
        if (!xc[0] || !yc[0])
          return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }
        t.reverse();
        for (; a--; t.push(0))
          ;
        t.reverse();
      }
      a = xc.length;
      b = yc.length;
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }
      for (a = 0; b; ) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }
      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }
      return normalise(y, xc, ye);
    };
    P.precision = P.sd = function(sd, rm) {
      var c, n, v, x = this;
      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(new BigNumber2(x), sd, rm);
      }
      if (!(c = x.c))
        return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;
      if (v = c[v]) {
        for (; v % 10 == 0; v /= 10, n--)
          ;
        for (v = c[0]; v >= 10; v /= 10, n++)
          ;
      }
      if (sd && x.e + 1 > n)
        n = x.e + 1;
      return n;
    };
    P.shiftedBy = function(k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times("1e" + k);
    };
    P.squareRoot = P.sqrt = function() {
      var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }
      s = Math.sqrt(+valueOf(x));
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0)
          n += "0";
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new BigNumber2(n);
      } else {
        r = new BigNumber2(s + "");
      }
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3)
          s = 0;
        for (; ; ) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));
          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
            if (r.e < e)
              --s;
            n = n.slice(s - 3, s + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              dp += 4;
              s += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
      }
      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };
    P.toExponential = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };
    P.toFixed = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };
    P.toFormat = function(dp, rm, format2) {
      var str, x = this;
      if (format2 == null) {
        if (dp != null && rm && typeof rm == "object") {
          format2 = rm;
          rm = null;
        } else if (dp && typeof dp == "object") {
          format2 = dp;
          dp = rm = null;
        } else {
          format2 = FORMAT;
        }
      } else if (typeof format2 != "object") {
        throw Error(bignumberError + "Argument not an object: " + format2);
      }
      str = x.toFixed(dp, rm);
      if (x.c) {
        var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }
        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1)
            intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0)
            intPart += groupSeparator + intDigits.slice(i);
          if (isNeg)
            intPart = "-" + intPart;
        }
        str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
          new RegExp("\\d{" + g2 + "}\\B", "g"),
          "$&" + (format2.fractionGroupSeparator || "")
        ) : fractionPart) : intPart;
      }
      return (format2.prefix || "") + str + (format2.suffix || "");
    };
    P.toFraction = function(md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
      if (md != null) {
        n = new BigNumber2(md);
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
        }
      }
      if (!xc)
        return new BigNumber2(x);
      d = new BigNumber2(ONE);
      n1 = d0 = new BigNumber2(ONE);
      d1 = n0 = new BigNumber2(ONE);
      s = coeffToString(xc);
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber2(s);
      n0.c[0] = 0;
      for (; ; ) {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1)
          break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }
      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
      ) < 1 ? [n1, d1] : [n0, d0];
      MAX_EXP = exp;
      return r;
    };
    P.toNumber = function() {
      return +valueOf(this);
    };
    P.toPrecision = function(sd, rm) {
      if (sd != null)
        intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };
    P.toString = function(b) {
      var str, n = this, s = n.s, e = n.e;
      if (e === null) {
        if (s) {
          str = "Infinity";
          if (s < 0)
            str = "-" + str;
        } else {
          str = "NaN";
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, "0");
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
        }
        if (s < 0 && n.c[0])
          str = "-" + str;
      }
      return str;
    };
    P.valueOf = P.toJSON = function() {
      return valueOf(this);
    };
    P._isBigNumber = true;
    P[Symbol.toStringTag] = "BigNumber";
    P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
    if (configObject != null)
      BigNumber2.set(configObject);
    return BigNumber2;
  }
  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }
  function coeffToString(a) {
    var s, z, i = 1, j = a.length, r = a[0] + "";
    for (; i < j; ) {
      s = a[i++] + "";
      z = LOG_BASE - s.length;
      for (; z--; s = "0" + s)
        ;
      r += s;
    }
    for (j = r.length; r.charCodeAt(--j) === 48; )
      ;
    return r.slice(0, j + 1 || 1);
  }
  function compare(x, y) {
    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
    if (!i || !j)
      return null;
    a = xc && !xc[0];
    b = yc && !yc[0];
    if (a || b)
      return a ? b ? 0 : -j : i;
    if (i != j)
      return i;
    a = i < 0;
    b = k == l;
    if (!xc || !yc)
      return b ? 0 : !xc ^ a ? 1 : -1;
    if (!b)
      return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    for (i = 0; i < j; i++)
      if (xc[i] != yc[i])
        return xc[i] > yc[i] ^ a ? 1 : -1;
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
    }
  }
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }
  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
  }
  function toFixedPoint(str, e, z) {
    var len, zs;
    if (e < 0) {
      for (zs = z + "."; ++e; zs += z)
        ;
      str = zs + str;
    } else {
      len = str.length;
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z)
          ;
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    return str;
  }
  var BigNumber = clone();
  var bignumber_default = BigNumber;

  // dist/qubicHelper.js
  var QubicHelper = class {
    constructor() {
      this.SEED_ALPHABET = "abcdefghijklmnopqrstuvwxyz";
      this.SHIFTED_HEX_CHARS = "abcdefghijklmnop";
      this.PRIVATE_KEY_LENGTH = 32;
      this.PUBLIC_KEY_LENGTH = 32;
      this.SEED_IN_LOWERCASE_LATIN_LENGTH = 55;
      this.CHECKSUM_LENGTH = 3;
      this.HEX_CHARS_PER_BYTE = 2;
      this.HEX_BASE = 16;
      this.SHIFTED_HEX_CHARS_NEW = "abcdefghijklmnopqrstuvwxyz";
      this.HEX_CHARS = "0123456789abcdef";
      this.REQUEST_RESPONSE_HEADER_SIZE = 8;
      this.TRANSACTION_SIZE = 144;
      this.IPO_TRANSACTION_SIZE = 144 + 8 + 2 + 6;
      this.SET_PROPOSAL_AND_BALLOT_REQUEST_SIZE = 592;
      this.TRANSACTION_INPUT_SIZE_OFFSET = 0;
      this.TRANSACTION_INPUT_SIZE_LENGTH = 0;
      this.SIGNATURE_LENGTH = 64;
      this.DIGEST_LENGTH = 32;
      this.SPECIAL_COMMAND_SHUT_DOWN = 0;
      this.SPECIAL_COMMAND_GET_PROPOSAL_AND_BALLOT_REQUEST = 1;
      this.SPECIAL_COMMAND_GET_PROPOSAL_AND_BALLOT_RESPONSE = 2;
      this.SPECIAL_COMMAND_SET_PROPOSAL_AND_BALLOT_REQUEST = 3;
      this.SPECIAL_COMMAND_SET_PROPOSAL_AND_BALLOT_RESPONSE = 4;
      this.PROCESS_SPECIAL_COMMAND = 255;
    }
    async createPublicId(seed2) {
      return crypto_default.then(({ schnorrq, K12 }) => {
        return this.createIdentity(seed2, 0).then((oldId) => {
          let privateKey = this.privateKey(seed2, 0, K12);
          let publicKey = schnorrq.generatePublicKey(privateKey);
          let publicId = this.getNewId(this.getPublicKeyOld(oldId));
          return {
            publicKey,
            privateKey,
            publicId
          };
        });
      });
    }
    getPublicKeyOld(identity) {
      const bytes = this.shiftedHexToBytes(identity.toLowerCase());
      return bytes;
    }
    shiftedHexToBytes(hex) {
      if (hex.length % this.HEX_CHARS_PER_BYTE !== 0) {
        hex = "a" + hex;
      }
      const bytes = new Uint8Array(hex.length / this.HEX_CHARS_PER_BYTE);
      for (let i = 0, c = 0; c < hex.length; c += this.HEX_CHARS_PER_BYTE) {
        bytes[i++] = parseInt(hex.substr(c, this.HEX_CHARS_PER_BYTE).split("").map((char) => this.HEX_CHARS[this.SHIFTED_HEX_CHARS.indexOf(char)]).join(""), this.HEX_BASE);
      }
      return bytes;
    }
    getNewId(publicKey) {
      let newId = "";
      for (let i = 0; i < 4; i++) {
        let longNUmber = new bignumber_default(0);
        longNUmber.decimalPlaces(0);
        publicKey.slice(i * 8, (i + 1) * 8).forEach((val, index) => {
          longNUmber = longNUmber.plus(new bignumber_default((val * 256 ** index).toString(2), 2));
        });
        for (let j = 0; j < 14; j++) {
          newId += String.fromCharCode(longNUmber.mod(26).plus("A".charCodeAt(0)).toNumber());
          longNUmber = longNUmber.div(26);
        }
      }
      let lastNumber = new bignumber_default(0);
      lastNumber.decimalPlaces(0);
      publicKey.slice(32, 35).forEach((val, index) => {
        lastNumber = lastNumber.plus(new bignumber_default((val * 256 ** index).toString(2), 2));
      });
      lastNumber = new bignumber_default(lastNumber.toNumber() & 262143);
      for (let i = 0; i < 4; i++) {
        newId += String.fromCharCode(lastNumber.mod(26).plus("A".charCodeAt(0)).toNumber());
        lastNumber = lastNumber.div(26);
      }
      return newId;
    }
    getHumanReadableBytes(publicKey) {
      let newId = "";
      for (let i = 0; i < 4; i++) {
        let longNUmber = new bignumber_default(0);
        longNUmber.decimalPlaces(0);
        publicKey.slice(i * 8, (i + 1) * 8).forEach((val, index) => {
          longNUmber = longNUmber.plus(new bignumber_default((val * 256 ** index).toString(2), 2));
        });
        for (let j = 0; j < 14; j++) {
          newId += String.fromCharCode(longNUmber.mod(26).plus("a".charCodeAt(0)).toNumber());
          longNUmber = longNUmber.div(26);
        }
      }
      let lastNumber = new bignumber_default(0);
      lastNumber.decimalPlaces(0);
      publicKey.slice(32, 35).forEach((val, index) => {
        lastNumber = lastNumber.plus(new bignumber_default((val * 256 ** index).toString(2), 2));
      });
      lastNumber = new bignumber_default(lastNumber.toNumber() & 262143);
      for (let i = 0; i < 4; i++) {
        newId += String.fromCharCode(lastNumber.mod(26).plus("a".charCodeAt(0)).toNumber());
        lastNumber = lastNumber.div(26);
      }
      return newId;
    }
    bytesToShiftedHex(bytes) {
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += this.SHIFTED_HEX_CHARS[bytes[i] >> 4] + this.SHIFTED_HEX_CHARS[bytes[i] & 15];
      }
      return hex;
    }
    seedToBytes(seed2) {
      const bytes = new Uint8Array(seed2.length);
      for (let i = 0; i < seed2.length; i++) {
        bytes[i] = this.SEED_ALPHABET.indexOf(seed2[i]);
      }
      return bytes;
    }
    privateKey(seed2, index, K12) {
      const byteSeed = this.seedToBytes(seed2);
      const preimage = byteSeed.slice();
      while (index-- > 0) {
        for (let i = 0; i < preimage.length; i++) {
          if (++preimage[i] > this.SEED_ALPHABET.length) {
            preimage[i] = 1;
          } else {
            break;
          }
        }
      }
      const key2 = new Uint8Array(this.PRIVATE_KEY_LENGTH);
      K12(preimage, key2, this.PRIVATE_KEY_LENGTH);
      return key2;
    }
    async createIdentity(seed2, index) {
      if (!new RegExp(`^[a-z]{${this.SEED_IN_LOWERCASE_LATIN_LENGTH}}$`).test(seed2)) {
        throw new Error(`Invalid seed. Must be ${this.SEED_IN_LOWERCASE_LATIN_LENGTH} lowercase latin chars.`);
      }
      if (!Number.isInteger(index) || index < 0) {
        throw new Error("Illegal index.");
      }
      let that = this;
      return crypto_default.then(function({ schnorrq, K12 }) {
        const privateKey = that.privateKey(seed2, index, K12);
        const publicKey = that.createPublicKey(privateKey, schnorrq, K12);
        return that.bytesToShiftedHex(publicKey).toUpperCase();
      });
    }
    createPublicKey(privateKey, schnorrq, K12) {
      const publicKeyWithChecksum = new Uint8Array(this.PUBLIC_KEY_LENGTH + this.CHECKSUM_LENGTH);
      publicKeyWithChecksum.set(schnorrq.generatePublicKey(privateKey));
      K12(publicKeyWithChecksum.subarray(0, this.PUBLIC_KEY_LENGTH), publicKeyWithChecksum, this.CHECKSUM_LENGTH, this.PUBLIC_KEY_LENGTH);
      return publicKeyWithChecksum;
    }
    async createIpo(sourceSeed2, contractIndex, price, quantity, tick2) {
      return crypto_default.then(({ schnorrq, K12 }) => {
        const sourcePrivateKey = this.privateKey(sourceSeed2, 0, K12);
        const sourcePublicKey = this.createPublicKey(sourcePrivateKey, schnorrq, K12);
        const tx = new Uint8Array(this.IPO_TRANSACTION_SIZE).fill(0);
        const txView = new DataView(tx.buffer);
        for (let i2 = 0; i2 < this.IPO_TRANSACTION_SIZE; i2++) {
          tx[i2] = 0;
        }
        let offset = 0;
        let i = 0;
        for (i = 0; i < this.PUBLIC_KEY_LENGTH; i++) {
          tx[i] = sourcePublicKey[i];
        }
        offset = i;
        tx[offset] = contractIndex;
        offset++;
        for (i = 1; i < this.PUBLIC_KEY_LENGTH; i++) {
          tx[offset + i] = 0;
        }
        offset += i - 1;
        txView.setBigInt64(offset, BigInt(0), true);
        offset += 8;
        txView.setUint32(offset, tick2, true);
        offset += 4;
        txView.setUint16(offset, 1, true);
        offset += 2;
        txView.setUint16(offset, 16, true);
        offset += 2;
        txView.setBigInt64(offset, BigInt(price), true);
        offset += 8;
        txView.setInt16(offset, quantity, true);
        offset += 2;
        offset += 6;
        const digest = new Uint8Array(this.DIGEST_LENGTH);
        const toSign = tx.slice(0, offset);
        K12(toSign, digest, this.DIGEST_LENGTH);
        const signedtx = schnorrq.sign(sourcePrivateKey, sourcePublicKey, digest);
        tx.set(signedtx, offset);
        offset += this.SIGNATURE_LENGTH;
        return tx;
      });
    }
    async createTransaction(sourceSeed2, destPublicId2, amount2, tick2) {
      return crypto_default.then(({ schnorrq, K12 }) => {
        const sourcePrivateKey = this.privateKey(sourceSeed2, 0, K12);
        const sourcePublicKey = this.createPublicKey(sourcePrivateKey, schnorrq, K12);
        const destPublicKey = publicKeyStringToBytes(destPublicId2).slice(0, this.PUBLIC_KEY_LENGTH);
        const tx = new Uint8Array(this.TRANSACTION_SIZE).fill(0);
        const txView = new DataView(tx.buffer);
        let offset = 0;
        let i = 0;
        for (i = 0; i < this.PUBLIC_KEY_LENGTH; i++) {
          tx[i] = sourcePublicKey[i];
        }
        offset = i;
        for (i = 0; i < this.PUBLIC_KEY_LENGTH; i++) {
          tx[offset + i] = destPublicKey[i];
        }
        offset += i;
        txView.setBigInt64(offset, BigInt(amount2), true);
        offset += 8;
        txView.setUint32(offset, tick2, true);
        offset += 4;
        txView.setUint16(offset, 0, true);
        offset += 2;
        txView.setUint16(offset, 0, true);
        offset += 2;
        const digest = new Uint8Array(this.DIGEST_LENGTH);
        const toSign = tx.slice(0, offset);
        K12(toSign, digest, this.DIGEST_LENGTH);
        const signedtx = schnorrq.sign(sourcePrivateKey, sourcePublicKey, digest);
        tx.set(signedtx, offset);
        offset += this.SIGNATURE_LENGTH;
        return tx;
      });
    }
    getIncreasingNonceAndCommandType(type) {
      let timestamp = Math.floor(Date.now() / 1e3);
      const byteArray = new Uint8Array(8);
      const txView = new DataView(byteArray.buffer);
      txView.setUint32(0, timestamp, true);
      byteArray[7] = type;
      return byteArray;
    }
    async createProposal(protocol, computorIndex, operatorSeed, url) {
      return crypto_default.then(({ schnorrq, K12 }) => {
        const operatorPrivateKey = this.privateKey(operatorSeed, 0, K12);
        const operatorPublicKey = this.createPublicKey(operatorPrivateKey, schnorrq, K12);
        const encoder = new TextEncoder();
        const urlBytes = encoder.encode(url);
        const uri = new Uint8Array(255);
        const uriSize = urlBytes.length;
        uri.set(urlBytes);
        const proposal = new Uint8Array(this.SET_PROPOSAL_AND_BALLOT_REQUEST_SIZE + this.REQUEST_RESPONSE_HEADER_SIZE).fill(0);
        const txView = new DataView(proposal.buffer);
        let offset = 0;
        const size = 600;
        proposal[0] = size;
        proposal[1] = size >> 8;
        proposal[2] = size >> 16;
        offset += 3;
        proposal[offset] = this.PROCESS_SPECIAL_COMMAND;
        offset++;
        proposal[offset++] = Math.floor(Math.random() * 255);
        proposal[offset++] = Math.floor(Math.random() * 255);
        proposal[offset++] = Math.floor(Math.random() * 255);
        proposal[offset] = this.PROCESS_SPECIAL_COMMAND;
        offset++;
        var timeStamp = this.getIncreasingNonceAndCommandType(this.SPECIAL_COMMAND_SET_PROPOSAL_AND_BALLOT_REQUEST);
        for (let i = 0; i < timeStamp.length; i++) {
          proposal[offset + i] = timeStamp[i];
        }
        offset += timeStamp.length;
        txView.setUint16(offset, computorIndex, true);
        offset += 2;
        const padding = 6;
        for (let i = 0; i < padding; i++) {
          proposal[offset + i] = 0;
        }
        offset += padding;
        proposal[offset] = uriSize;
        offset++;
        for (let i = 0; i < uriSize; i++) {
          proposal[offset + i] = uri[i];
        }
        offset += 255;
        offset += 256;
        const digest = new Uint8Array(this.DIGEST_LENGTH);
        const toSign = proposal.slice(this.REQUEST_RESPONSE_HEADER_SIZE, offset);
        K12(toSign, digest, this.DIGEST_LENGTH);
        const signatur = schnorrq.sign(operatorPrivateKey, operatorPublicKey, digest);
        proposal.set(signatur, offset);
        offset += this.SIGNATURE_LENGTH;
        return proposal;
      });
    }
    VotesToByteArray(votes) {
      var bitArray = [];
      for (var computorIndex = 0; computorIndex < votes.length; computorIndex++) {
        var vote = votes[computorIndex];
        for (var i = 0; i < 3; i++) {
          var bit = vote >> i & 1;
          bitArray.push(bit);
        }
      }
      var output = new Uint8Array(Math.ceil(bitArray.length / 8));
      for (var k = 0; k < bitArray.length; k += 8) {
        var byteIndex = Math.floor(k / 8);
        var byteValue = 0;
        for (var j = 0; j < 8; j++) {
          var bit = bitArray[k + j] || 0;
          byteValue |= bit << j;
        }
        output[byteIndex] = byteValue;
      }
      return output;
    }
    async createBallotRequests(protocol, operatorSeed, computorIndices, votes) {
      return crypto_default.then(({ schnorrq, K12 }) => {
        const output = [];
        const operatorPrivateKey = this.privateKey(operatorSeed, 0, K12);
        const operatorPublicKey = this.createPublicKey(operatorPrivateKey, schnorrq, K12);
        for (let index = 0; index < computorIndices.length; index++) {
          const proposal = new Uint8Array(this.SET_PROPOSAL_AND_BALLOT_REQUEST_SIZE + this.REQUEST_RESPONSE_HEADER_SIZE).fill(0);
          const txView = new DataView(proposal.buffer);
          let offset = 0;
          const size = 600;
          proposal[0] = size;
          proposal[1] = size >> 8;
          proposal[2] = size >> 16;
          offset += 3;
          proposal[offset] = this.PROCESS_SPECIAL_COMMAND;
          offset++;
          proposal[offset++] = Math.floor(Math.random() * 255);
          proposal[offset++] = Math.floor(Math.random() * 255);
          proposal[offset++] = Math.floor(Math.random() * 255);
          proposal[offset] = this.PROCESS_SPECIAL_COMMAND;
          offset++;
          var timeStamp = this.getIncreasingNonceAndCommandType(this.SPECIAL_COMMAND_SET_PROPOSAL_AND_BALLOT_REQUEST);
          for (let i = 0; i < timeStamp.length; i++) {
            proposal[offset + i] = timeStamp[i];
          }
          offset += timeStamp.length;
          txView.setUint16(offset, computorIndices[index], true);
          offset += 2;
          const padding = 6;
          for (let i = 0; i < padding; i++) {
            proposal[offset + i] = 0;
          }
          offset += padding;
          proposal[offset] = 0;
          offset++;
          offset += 255;
          offset++;
          var voteBytes = this.VotesToByteArray(votes);
          for (let i = 0; i < voteBytes.length; i++) {
            proposal[offset++] = voteBytes[i];
          }
          offset++;
          const digest = new Uint8Array(this.DIGEST_LENGTH);
          const toSign = proposal.slice(this.REQUEST_RESPONSE_HEADER_SIZE, offset);
          K12(toSign, digest, this.DIGEST_LENGTH);
          const signatur = schnorrq.sign(operatorPrivateKey, operatorPublicKey, digest);
          proposal.set(signatur, offset);
          offset += this.SIGNATURE_LENGTH;
          output.push(proposal);
        }
        return output;
      });
    }
    downloadBlob(fileName, blob) {
      if (window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, fileName);
      } else {
        const anchor = window.document.createElement("a");
        anchor.href = window.URL.createObjectURL(blob);
        anchor.download = fileName;
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
        window.URL.revokeObjectURL(anchor.href);
      }
    }
  };

  // dist/arrayBufferUtil.js
  function arrayBufferToBase64(buffer2) {
    var binary = "";
    var bytes = new Uint8Array(buffer2);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  // dist/index.js
  var qubicHelper = new QubicHelper();
  var command = "";
  var seed = "";
  var sourceSeed = "";
  var destPublicId = "";
  var amount = "";
  var tick = "";
  var timer = setTimeout(() => {
  }, 999999);
  try {
    if (process.argv[2] == "createPublicId") {
      command = "createPublicId";
      if (process.argv.length != 4) {
        throw "Invalid number of arguments. Please provide a seed.";
      }
      seed = process.argv[3];
      qubicHelper.createPublicId(seed).then((result) => {
        process.stdout.write(JSON.stringify({ status: "ok", publicId: result.publicId }));
        clearTimeout(timer);
      });
    } else if (process.argv[2] == "createTransaction") {
      command = "createTransaction";
      if (process.argv.length != 7) {
        throw "Invalid number of arguments. Please provide a sourceSeed destPublicId amount tick.";
      }
      sourceSeed = process.argv[3];
      destPublicId = process.argv[4];
      amount = process.argv[5];
      if (!/^\d+$/.test(amount)) {
        throw "Invalid amount. Please provide a numeric value without decimals.";
      }
      tick = process.argv[6];
      if (!/^\d+$/.test(tick)) {
        throw "Invalid tick. Please provide a numeric value without decimals.";
      }
      let result = qubicHelper.createTransaction(sourceSeed, destPublicId, parseInt(amount), parseInt(tick)).then((result2) => {
        process.stdout.write(JSON.stringify({
          status: "ok",
          transaction: arrayBufferToBase64(result2)
        }));
        clearTimeout(timer);
      });
    } else {
      throw "Invalid command. Please provide a valid command (createPublicId, createTransaction).";
      clearTimeout(timer);
    }
  } catch (error) {
    process.stdout.write(JSON.stringify({ status: "error", error }));
    clearTimeout(timer);
  }
})();
